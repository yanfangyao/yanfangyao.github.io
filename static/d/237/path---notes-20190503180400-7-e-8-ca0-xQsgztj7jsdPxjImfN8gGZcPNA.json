{"data":{"site":{"siteMetadata":{"title":"William's Blog","author":"William"}},"markdownRemark":{"id":"ef7442e3-8c87-513f-b15a-2744f9b9b9a5","excerpt":"JavaScript异步编程的背景知识 　　javascript引擎是基于单线程事件循环的概念构建的，同一时刻只能执行一个代码块。为了实现异步，javascript…","html":"<h2>JavaScript异步编程的背景知识</h2>\n<p>　　javascript引擎是基于单线程事件循环的概念构建的，同一时刻只能执行一个代码块。为了实现异步，javascript引擎引入事件循环和任务队列机制。当某段代码需要被执行时，它会被添加到任务队列中，当任务队列前面的任务被执行完成后，事件循环会开始执行该代码。当一个异步操作结束并且需要执行响应程序时，javascript引擎会将响应程序添加到任务队列中，在下一次事件循环时执行。</p>\n<h2>侦听事件</h2>\n<p>　　在Web应用中，浏览器会通过触发一些事件来响应用户交互，例如当用户点击页面按钮时会触发浏览器的click事件。开发者可以侦听这些事件并注册处理函数来作出一些响应。当某个事件被触发时，对应的事件处理函数会被添加到javascript引擎的任务队列中，然后被执行。一个常见的应用侦听事件的方式实现异步响应用户交互的示例如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> button <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nbutton<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You clicked button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　当用户点击页面button元素时，javascript引擎会执行console.log(‘You clicked button’)语句，打印出 ‘You clicked button’。<br>\n　　侦听事件实现异步的方式只适合处理简单的交互，当处理复杂的逻辑时，使用侦听事件的方式往往需要追踪每个事件的事件目标，代码逻辑因此可能会变得复杂并且难以调试，此外，事件处理函数必须在事件被触发前注册，否则事件处理函数不会被执行。</p>\n<h2>回调函数</h2>\n<p>　　回调函数一般是以函数参数的形式进行传递，给要执行异步操作的函数传入一个回调函数作为参数，当异步操作结束时，调用回调函数来响应异步操作。以Web应用中常见的ajax请求为例来说明回调函数的用法：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>api<span class=\"token punctuation\">,</span> method<span class=\"token punctuation\">,</span> successCallback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  xhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">,</span> api<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  xhr<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onreadystatechange</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">===</span> <span class=\"token number\">4</span> <span class=\"token operator\">&amp;&amp;</span> xhr<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token function\">successCallback</span><span class=\"token punctuation\">(</span><span class=\"token string\">'success'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  xhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 调用fetchData</span>\n<span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'/api/'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'get'</span><span class=\"token punctuation\">,</span>\n  console<span class=\"token punctuation\">.</span>log\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　函数fetchData封装了异步请求并接受一个回调函数作为参数，当异步请求成功时，回调函数被调用并进行相应的处理。上述示例中，当异步请求成功时，javascript引擎将回调函数添加到任务队列中，执行后打印出 ‘success’。<br>\n　　与侦听事件的方式相比较，回调函数的方式更灵活，可以很方便地将多个独立的异步操作链接起来：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 调用fetchData</span>\n<span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'/api1/'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'get'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>\n     <span class=\"token string\">'/api2/'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'get'</span><span class=\"token punctuation\">,</span>\n      console<span class=\"token punctuation\">.</span>log\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　上述示例中，通过回调函数将两个异步请求链接起来，当/api1/请求成功后，会发起/api2/的请求，只有两个请求都成功时，javascript引擎才会打印出 ‘success’。<br>\n　　虽然回调函数的链式调用很方便，但是其缺点也显而易见。当函数嵌套层次过多时，很容易形成 “回调地狱” ，严重影响代码的可读性，一个 “回调地狱” 示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">method1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token function\">method2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    \n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     \n     <span class=\"token function\">method3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n       \n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       \n       <span class=\"token function\">method4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n         \n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n         \n         <span class=\"token function\">method5</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>  除了 “回调地狱” 外，回调函数还有以下局限性:</p>\n<ol>\n<li>对于嵌套的函数调用，需要针对每一层级的调用进行错误处理，使得代码变得繁琐。</li>\n<li>当并行执行多个异步操作时，如同时发送2个异步请求，单纯使用回调函数无法很好管理它们的状态，需要额外编写代码追踪多个回调函数来实现对异步操作的管理。</li>\n</ol>\n<h2>setTimeout/setInterval/requestAnimationFrame</h2>\n<p>　　当需要在特定时间之后执行某个任务时，可以使用setTimeout/setInterval/requestAnimationFrame来实现。setTimeout用来实现特定延时之后执行某个任务，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'elapsed'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">1000</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　当javascript引擎执行到setTimeout时，javascript引擎并不会立即将回调函数添加到任务队列中，而是在1000ms之后才会将其添加到任务队列中。当新的事件循环开始时会执行setTimeout回调函数打印出 ‘elapsed’。<br>\n　　setInterval和requestAnimationFrame都用来实现定期执行某一任务，他们的不同之处在于，setInterval可以让开发者自定义任务执行间隔，而requestAnimationFrame的回调函数会在浏览器渲染下一帧前执行，其执行间隔依赖于当前屏幕的帧率。一般而言，当需要使用javascript实现动画时，优先使用requestAniamtionFrame，这样实现的动画更加流畅。</p>\n<h2>Promise</h2>\n<p>　　Promise对象的作用是管理异步操作状态，在任一时刻，它只可能处于以下三种状态中的一种：</p>\n<ol>\n<li>Pending，进行态。该状态表示异步操作尚未完成。</li>\n<li>Fulfilled，完成态。该状态表示异步操作成功完成。</li>\n<li>Rejected，拒绝态。该状态表示程序出错或者其他原因导致异步操作未能成功完成。</li>\n</ol>\n<p>　　Promise对象的状态变换是单向和一次性的，只能由Pending状态变换为Fulfilled或者Rejected状态。Promise对象有一个then方法，通过then方法可以在Promise对象的状态发生变换时执行相应的动作。then方法接受两个可选参数，第一个是当Promise对象的状态变为Fulfilled时要调用的函数，与异步操作成成功时相关的数据都可以传递给这个函数；第二个是当Promise对象的状态变为Rejected时要调用的函数，与异步操作失败相关的数据都可以传递给这个函数。<br>\n　　使用Promise构造函数可以创建Promise对象，Promise构造函数接受一个参数：包含初始化Promise代码的执行器（executor）函数。执行器函数接受两个函数作为参数：resolve和reject。执行器函数会开启异步任务，当异步任务成功完成时，调用resolve函数并传入异步任务返回的数据；当异步任务失败时，调用reject函数并传入失败原因。传入执行器函数的resolve和reject函数是由Promise内部实现的，通过这两个函数，Promise对象可以知道异步任务当前的状态，从而变换自身状态并执行使用then方法注册的处理函数。调用resolve或reject函数时，使用then方法注册的处理函数并不会被立即执行，而是被添加到javascript引擎的任务队列中等待下一次事件循环再执行。<br>\n　　使用Promise对象对上文中的fetchData函数进行重构：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>api<span class=\"token punctuation\">,</span> method<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      xhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">,</span> api<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      xhr<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onreadystatechange</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">===</span> <span class=\"token number\">4</span> <span class=\"token operator\">&amp;&amp;</span> xhr<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'success'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>        <span class=\"token punctuation\">}</span>\n<span class=\"gatsby-highlight-code-line\">        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'failure'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      xhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 调用fetchData返回对应的Promise对象</span>\n<span class=\"token keyword\">const</span> p <span class=\"token operator\">=</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'get'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 调用Promise对象的then方法，在异步任务成功/失败时执行打印动作</span>\np<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　除了在then方法中处理异步任务的异常之外，还可以调用Promise对象的catch方法来统一捕获所有异常。catch方法接受一个回调函数来处理异步任务的异常，回调函数参数为异常信息。then方法和catch方法均会返回新的Promise对象使其可以被链式调用。串联的Promise对象只有当前一个Promise对象的状态变成Fulfilled或者Rejected时，其才会被处理。使用then方法的链式调用实现请求/api/成功后再打印新信息的功能：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'get'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'new Promise'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　链式调用的then方法和catch方法可以通过回调函数的return语句从前一级向后一级传递值，对于不同类型的返回值，javascript引擎对then方法或catch方法新返回的Promise对象的处理如下：</p>\n<ol>\n<li>返回值为非Promise对象。新创建的Promise对象状态为Fulfilled，并且存储的值为返回值。</li>\n<li>返回值为Promise对象。新创建的Promise对象会接管返回值的状态和值。</li>\n<li>抛出异常。新创建的Promise对象的状态为Rejected，并且存储的值为抛出的异常信息。</li>\n</ol>\n<p>　　一个简单的Promise链式调用传递值的示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> p1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> p2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\np1<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'操作失败'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'操作完成'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> p2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上述示例最终打印出的结果和顺序如下：<br>\n<strong>1</strong><br>\n<strong>2</strong><br>\n<strong>操作失败</strong><br>\n<strong>操作完成</strong><br>\n<strong>-1</strong><br>\n　　Promise对象可以让开发者非常方便地管理多个异步任务的状态和执行流程，与侦听事件和回调函数这两种方式相比，Promise可以确保当异步操作完成之后对应的处理函数一定会被执行，而且使用Promise对象编写的代码结构也清晰易读。除此之外，Promise对象还提供了all和race两种方法，解决了同时监听多个异步任务的问题。all和race方法均接受一个包含多个Promise对象的可迭代对象作为参数并且返回一个Promise对象，但是两个方法表现不一样：<br>\n　　对于all方法而言，只有当可迭代对象中的所有Promise对象的状态均变成Fulfilled时，all方法返回的Promise对象的状态才会变成Fulfilled并且其值是一个按可迭代对象中的迭代顺序存放所有被监听的Promise对象返回值的数组；当可迭代对象有一个Promise对象状态变为Rejected时，all方法返回的Promise对象的状态会变成Rejected并且其值为可迭代对象中达到Rejected状态的Promise对象的返回值。<br>\n　　对于race方法而言，只要可迭代对象中的某个Promise对象达到Fulfilled状态或者Rejected状态，race方法返回的Promise对象的状态就会转变成Fulfilled或者Rejected状态并且保存迭代对象中达到Fulfilled状态或者Rejected状态的Promise对象的值。<br>\n　　Promise对象是现代javascript组织异步编程的主要方式，但是当then的链式回调很长或者then回调中再次嵌套新Promise链式调用时，整个代码逻辑和可读性就会变的很差，和 “回调地狱” 产生一样的效果。有没有一种类似于编写同步任务代码的方式来编写异步任务代码？</p>\n<h2>生成器</h2>\n<p>　　生成器是一种特殊的函数，返回迭代器。什么是迭代器？迭代器是一种特殊的对象，它拥有一个next方法，每次调用会返回一个结果对象，结果对象有两个属性：1\n、value，表示下一个将要返回的值；2、done，是一个bool值，用来标志是否还有更多数据待返回。每个迭代器内部还保存一个内部指针，用来指向当前集合中值的位置，每次调用next方法都会返回下一个可用的值。当迭代器返回最后一个值后再次调用next方法，那么返回的结果对象中属性done的值为true，属性value则包含迭代器最终返回的值，这个返回值不是数据集合的一部分，它与函数的返回值类似，是函数调用过程中最后一次给调用者传递信息的方法，如果没有相关数据则返回undefined。<br>\n　　使用function关键字定义函数时，在function关键字后面添加星号（*）可以定义一个生成器函数，星号（*）可以紧挨着function关键字，也可以在中间添加一个空格。在生成器函数中使用关键字yield可以指定生成的迭代器的next方法被调用时返回的结果对象的值。一个简单的用生成器生成迭代器的示例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token operator\">*</span><span class=\"token function\">createIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> iterator <span class=\"token operator\">=</span> <span class=\"token function\">createIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　上述代码打印出的结果及其顺序如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> undefined<span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>　　生成器有一个很有趣的特点：每当执行完一条yield语句之后，生成器函数就会自动停止执行，当生成的迭代器的next方法再次被调用时，生成器会执行下一个yield语句。试想一下，如果使用yield语句可以返回异步调用的结果，那么使用生成器就可以像编写同步任务代码那样来编写异步任务代码。</p>\n<h3>使用Promise和生成器组织异步编程</h3>\n<p>　　以上文中使用Promise重构的fetchData函数为例说明如何使用生成器以”同步”编程的方式组织异步代码。<br>\n　　首先，使用生成器定义一个任务函数，执行所有异步操作：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token operator\">*</span><span class=\"token function\">taskDef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'get'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>　　然后，创建一个执行任务的函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>taskDef<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> task <span class=\"token operator\">=</span> <span class=\"token function\">taskDef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> task<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token comment\">// 递归执行所有异步操作</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 使用Promise封装返回的结果</span>\n      Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 将异步操作返回的数据注入到生成器中替换yield语句的返回值，后续操作可以使用该值</span>\n        result <span class=\"token operator\">=</span> task<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> task<span class=\"token punctuation\">.</span><span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>　　最后使用run方法执行任务函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>taskDef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　当fecthData这个异步函数执行成功之后，run函数会打印出 ‘success’，当fetchData执行失败之后，run函数抛出错误，此时程序退出。<br>\n　　考察上面的示例，如果我们将run函数封装成一个通用的函数，那每次实现异步编程时，我们只需要创建一个生成器，在生成器中使用yield关键字返回一个Promise对象然后调用run方法传入生成器就可以了。开发者只需要关注生成器的创建，使用yield关键字以”同步”的方式编写异步代码。</p>\n<h2>async/await</h2>\n<p>　　async/await是ES 7中引入的语法糖，其引入的目的是更加方便开发者以”同步”的方式编写异步代码，其本质上是在内部使用生成器和Promise对象实现了上述run方法的功能从而让异步编程变得简单。<br>\n　　本文不再对async/await做过多的介绍，详情可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">mdn官方文档</a>。</p>\n<h2>总结</h2>\n<p>　　本文总结了javascript常见的异步编程的方式，从原始的侦听事件和回调函数模式到现代基于Promise和生成器实现的采用”同步”的方式编写异步代码的模式。对于开发者而言，没有哪一种方法是完美的，开发者需要根据使用场景灵活选取实现异步编程的方式。</p>\n<h2>参考文献</h2>\n<ol>\n<li><a href=\"https://github.com/nzakas/understandinges6\">Understanding ECMAScript 6</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous\">mdn: Asynchronous Java​Script</a></li>\n<li><a href=\"https://promisesaplus.com/#notes\">Promises/A+</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await\">mdn: Making asynchronous programming easier with async and await</a></li>\n</ol>","frontmatter":{"title":"JavaScript的异步编程","date":"May 03, 2019","description":"javascript作为一种为Web应用而生的语言，需要应对各种异步场景：用户点击、滑动等交互，网络请求等。使用javascript语言实现异步编程是前端开发工程师经常面对的问题。本博文总结了javascript实现异步编程的几种方式，并分析了其各自的特点和适用场景。"}}},"pageContext":{"slug":"/notes/20190503180400/","previous":{"fields":{"slug":"/notes/20190331140214/"},"frontmatter":{"title":"如何理解React框架中的element、component以及instance？"}},"next":null}}