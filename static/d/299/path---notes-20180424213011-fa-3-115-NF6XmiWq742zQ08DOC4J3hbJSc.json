{"data":{"site":{"siteMetadata":{"title":"William's Blog","author":"William"}},"markdownRemark":{"id":"bcd6573e-8380-54ca-a7fe-131f8f8c4f67","excerpt":"解析HTML文档流程 　　现代浏览器解析html文档的流程如图1所示（图片摘自 html5标准 ）。 　　上述解析流程中各个处理阶段的功能说明如下： \n　　（1）Byte Stream Decoder（字节流解码器）：将获取到的html文档字节流解析成Unicode编码表示的字符流。关于更多解码细节，可以 查看html…","html":"<h2>解析HTML文档流程</h2>\n<p>　　现代浏览器解析html文档的流程如图1所示（图片摘自<a href=\"https://www.w3.org/TR/html5/syntax.html#parsing-html-documents\">html5标准</a>）。</p>\n<div style=\"text-align: center;\">\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3b0307e1ca3bb2fedf87a48365124d14/c0d9d/html_parsing_flow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 345px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 155.07246376811594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAIAAABoLHqZAAAACXBIWXMAAAsTAAALEwEAmpwYAAADd0lEQVQ4y5WVi1PiSBCH/fuvaq9WzlNct+7YOl0FFU5QWVdF3ss7CYlIlFceJBlCQhJCeCSBm6Dlgacr96vJVJLJ193T0zNZm81mlmXJvZ7aV1VN7Sk9We7xPC/LMhyaTqezt7UGL0mVKgIRyV9GiteZu0zbZK6zlyIQ34eNkREB3y4HoWN6/7C1dyb5j2v7xXLhXdKB6Q71Nf/lEPl6jB0coQdebPcsFzRH5mwFOWHPbOhlZo1sqk459/ZsRTmwPtD7el9RlVg8Np6MVVXRdX2lsOHVbDfC8fNYPppGEzfZ6xT+g6gSq8K4hJ5QPveVazv6+5fszjcx9INIrQonG/EddOPPkns7t+HBPm0XXMly3EnF1H4fNiempvY1RaMpRtd0TdVMc+VsT8YTyPf7ejQatW17NBz9D5jhaaRSIqlqqYKUSax8j1WqlcU5T38CYyzyx9XWXuqv3bjnU3jLV9z3nXnbNMMyDE0z7TYHgNCeCwAwmUyW4Hgrsln+4EbW3cjHbdTlKvwSK0ckQWzUayR5D40IgsCyLM0wAgDD4XAJ7inyQ6vWYBrV2l2TbdZaD3BvvbpUw9HQGBrL5Tn/Zjwap5Np58mePpIv5MDD/8BAFGieYgFL1kkgAZqnm63Gqp7r0kNJzISx0wvsLIyeFqV8sVJYFU4y0V3u8xHYPeA8sPc03Tfo1asV9grc4psxNJIiElEkkr5Nwp7mqBee/52zYTzahW/Wnodty8Yx/NVoYdm96Vnsip1uh+XYTC4jKRIntHmBX7QC7fKA78pdim7RLC31ui26Bfe8A9eEh4qE5xuZUOKkSBXwDpZFM7DgYYSPcSIoWhEJXEACN4f+Gz+pVHP1DMdzDpxmEr8VPrjzLrgZt3Lrm8jH69KlNbYHxmA4F35LBKiDz/jGZm59I/Orh9zZu/VwXNuBCbocKPnO8WAQ8Z8TQX/BW2ksnSSWbX3HwyEsEEIDsD/F/w5m/VpfW0iYadfJ+pyZvZUwy7TMibWUMHj0wYQBESRSCVmRBcD3ei9/F/bUms7s8WQE29TJoPW0VAxggCEA3Wkdo8MqTPm2/OqamXMteb7vVEmTSNQjvuR+VkyjRiGJJOAsRnONFwST9zyFJzjbTp/I3ot+MEB7T+6Ojove0l3xuYwWPb94fCrPC+T8OxKG+4Hn+IE2WDT/E/0D9+S6YzH/1JMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"现代浏览器解析html文档的流程\"\n        title=\"\"\n        src=\"/static/3b0307e1ca3bb2fedf87a48365124d14/c0d9d/html_parsing_flow.png\"\n        srcset=\"/static/3b0307e1ca3bb2fedf87a48365124d14/b8469/html_parsing_flow.png 148w,\n/static/3b0307e1ca3bb2fedf87a48365124d14/ec75a/html_parsing_flow.png 295w,\n/static/3b0307e1ca3bb2fedf87a48365124d14/c0d9d/html_parsing_flow.png 345w\"\n        sizes=\"(max-width: 345px) 100vw, 345px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n</div>\n<div style=\"text-align: center;\">图 1 现代浏览器解析html文档的流程</div>\n<p>　　上述解析流程中各个处理阶段的功能说明如下：<br>\n　　（1）Byte Stream Decoder（字节流解码器）：将获取到的html文档字节流解析成Unicode编码表示的字符流。关于更多解码细节，可以<a href=\"https://www.w3.org/TR/html5/syntax.html#the-input-byte-stream\">查看html5标准</a>。<br>\n　　（2）Input Stream Preprocessor（输入字符流预处理器）：对解码产生的Unicode字符流进行预处理，如忽略”回车”（CR）后面紧跟的”换行”（LF），然后将所有的”回车”（CR）替换成”换行（LF）“。关于更多预处理字符流的操作，可以<a href=\"https://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\">查看html5标准</a>。<br>\n　　（3）Tokenizer（标记生成器）：处理html字符流，生成html标记并将标记传送给树生成器。html标记有以下几种：DOCTYPE、起始标签、结束标签、注释、字符、EOF(文件结束标志)。关于标记生成器的更多细节操作，可以<a href=\"https://www.w3.org/TR/html5/syntax.html#tokenization\">查看html5标准</a>。<br>\n　　（4）Tree Construction（树构建）：根据标记生成器产生的一系列html标记，构建DOM树。关于树构建过程的更多细节，可以<a href=\"https://www.w3.org/TR/html5/syntax.html#tree-construction\">查看html5标准</a>。<br>\n　　（5）Script Execution（执行脚本）：执行javascript脚本。</p>\n<h2>标记化算法</h2>\n<p>　　标记生成器使用标记化算法从html字符流中提取出html标记用于构建DOM树。由于html语法不是一个与上下文无关的语法，并且解析的过程也可能动态改变html文档（如在树构建的过程中执行document.write()），于是用状态机的形式来表示标记化算法。状态机中的每个状态接受一个或者多个输入字符流中的字符，并且根据这些字符来确定下一个状态。每一次状态的改变是由当前标记状态以及当前树构建状态来决定的。标记化算法具体的实现非常复杂，本文拟通过一个简单的示例来说明标记化算法的基本原理，对其更深入细致的实现不作介绍。关于算法的更多细节，可以<a href=\"https://www.w3.org/TR/html5/syntax.html#tokenization\">查看html5标准</a>。<br>\n　　使用标记化算法将下面的html片段标记化：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>解析html文档<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Hello, world!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>　　上述html片段的标记化过程中各个状态切换流程如下：<br>\n　　（1）初始状态为 “数据状态”（Data state）。<br>\n　　（2）当遇到字符&#x3C;时，状态切换到 “标签打开状态”（Tag open state）。<br>\n　　（3）当遇到字符!时，状态切换至 “标记声明打开状态”（Markup declaration open state）。在该状态下，如果后续两个字符都是连字符-，则创建一个注释标记，设置标记的数据为空，并且跳转到 “注释开始状态”（Comment start state）。如果后续7个字符可以组成字符串 “DOCTYPE”（不区分大小写），则当前状态会跳转到 “DOCTYPE状态”（DOCTYPE state）。根据上述代码片段，当前状态会跳转到 “DOCTYPE状态” 。<br>\n　　（4）下一个字符为空格，当前状态切换至 “DOCTYPE名称之前状态”（Before DOCTYPE name state）。<br>\n　　（5）当遇到字符串 “html” 时，创建一个新的DOCTYPE标记，标记的名字为 “html” 。然后当前状态切换至 “DOCTYPE名字状态”（DOCTYPE name state）。<br>\n　　（6）当遇到字符>，当前状态跳转到 “数据状态” 并且释放当前的DOCTYPE标记。<br>\n　　（7）当遇到字符&#x3C;, 当前状态切换到 “标签打开状态” 。<br>\n　　（8）遇到字符h，创建一个新的起始标签标记，设置标记的标签名为空，当前状态切换至 “标签名称状态”（Tag name state）。<br>\n　　（9）重新从字符h开始解析，将解析的字符一个一个添加到创建的起始标签标记的标签名中，直到遇到字符>。此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “html” 。<br>\n　　（10）解析后续的&#x3C;head>和&#x3C;title>的方式与&#x3C;html>一致，创建并释放对应的起始标签标记，解析完毕后，当前状态处于 “数据状态” 。<br>\n　　（11）遇到字符串 “解析html文档” ，针对每一个字符，创建并释放一个对应的字符标记，解析完毕后，当前状态仍然处于 “数据状态” 。<br>\n　　（12）遇到字符&#x3C;, 进入 “标签打开状态” 。<br>\n　　（13）遇到字符/, 进入 “结束标签打开状态”（End tag open state）。<br>\n　　（14）遇到字符t，创建一个新的结束标签标记，设置标记的标签名为空，当前状态切换至”标签名称状态”（Tag name state）。<br>\n　　（15）重新从字符t开始解析，将解析的字符一个一个添加到创建的结束标签标记的标签名中，直到遇到字符>。此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “title” 。<br>\n　　（16）解析&#x3C;/head>的方式与&#x3C;/title>一样。<br>\n　　（17）对于后续的html标签和文本的解析，可以参照（1）~（16）的流程来解析。<br>\n　　（18）所有的html标签和文本解析完成后，状态切换至 “数据状态” ，一旦遇到文件结束标志符（EOF），则释放EOF标记。</p>\n<h2>树构建算法</h2>\n<p>　　当html解析器被创建的同时，浏览器会创建一个Document对象。在树构建阶段，以Document为根节点的DOM树会得到不断的修改或扩充。标记生成器产生的每个标记被送到树构建器进行处理。html5标准中定义了每类标记对应的DOM元素，当树构建器接收到某个标记时就会创建该标记对应的DOM元素并将该元素插入到DOM树中。为了纠正元素标签嵌套错位的问题和处理未关闭的元素标签，树构建器创建的新DOM元素还会被插入到一个开放元素栈中。树构建算法也可以采用状态机的方式来描述，每个状态都对应一个状态变量insertion mode，该变量可以取值 “initial”、“before html”、“before head”、“after after body” 等。<br>\n　　使用树构建算法处理以下html片段生成的标记：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>解析html文档<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Hello, world!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>　　针对标记化算法创建的标记，使用树构建算法处理的过程中，各个状态的切换流程如下：<br>\n　　（1）树构建的初始状态是 “initial” 模式。<br>\n　　（2）树构建器接收到标记生成器释放出来的DOCTYPE标记后，树构建器会创建一个DocumentType节点附加在Document节点上，DocumentType节点的name属性为DOCTYPE标记的名字。切换当前的状态为 “before html” 模式。<br>\n　　（3）接收到标记生成器释放的起始标签标记（标记名为 “html”）后，树构建器会创建一个HTMLHtmlElement元素（实现了HTMLHtmlElement接口）并将该元素作为Document的子节点插入DOM树中。新创建的HTMLHtmlElement元素也会被插入到一个开放元素栈中。当前状态切换为 “before head” 模式。<br>\n　　（4）接收到标记生成器释放的起始标签标记（标签名为 “head”）后，树构建器会创建一个HTMLHeadElement元素（实现了HTMLHeadElement接口）并将该元素作为HTMLHtmlElement元素的子节点插入DOM树中。新创建的HTMLHeadElement元素也会被插入到一个开放元素栈中。当前状态切换为 “in head” 模式。<br>\n　　（5）接收到标记生成器释放的起始标签标记（标签名为 “title”）后，树构建器会创建一个HTMLTitleElement元素（实现了HTMLTitleElement接口）并将该元素作为HTMLHeadElement元素的子节点插入DOM树中。新创建的HTMLTitleElement元素也会被插入到一个开放元素栈中。当前状态切换为 “text” 模式。<br>\n　　（6）在 “text” 模式下，树构建器会创建一个Text节点（实现了Text接口）并将标记生成器释放的字符标记对应的字符添加到Text节点中。处理完字符标记后，Text节点会作为HTMLTitleElement元素的子节点插入到树中。<br>\n　　（7）在 “text” 模式下，接收到标记生成器释放的结束标签标记（标签名为 “title”）后，树构建器会将之前插入开放元素栈的HTMLTitleElement元素弹出。当前状态会返回状态机进入 “text” 模式之前的模式，本例为  “in head” 模式。<br>\n　　（8）接收到标记生成器释放的结束标签标记（标签名为 “head”）后，树构建起会将之前插入开放元素栈的HTMLHeadElement元素弹出。当前状态切换至 “after head” 模式。<br>\n　　（9）接收到标记生成器释放的起始标签标记（标签名为 “body”）后，树构建器会创建一个HTMLBodyElement元素（实现了HTMLBodyElement接口）并将该元素作为HTMLHtmlElement元素的子节点插入树中。新创建的HTMLBodyElement元素也会被插入到一个开放元素栈中。当前状态切换为 “in body” 模式。<br>\n　　（10）接收到标记生成器释放的起始标签标记（标签名为 “h1”）后，树构建器会创建一个HTMLHeadingElement元素（实现了HTMLHeadingElement接口）并将该元素作为HTMLBodyElement元素的子节点插入树中。新创建的HTMLHeadingElement元素也会被插入到一个开放元素栈中。<br>\n　　（11）接收到标记生成器释放的字符标记后，树构建器会创建一个Text节点（实现了Text接口）并将标记生成器释放的字符标记对应的字符添加到Text节点中。处理完字符标记后，Text节点会作为HTMLHeadingElement元素的子节点插入到树中。<br>\n　　（12）接收到标记生成器释放的结束标签标记（标签名为 “h1”）后，树构建器会将之前插入开放元素栈的HTMLHeadingElement元素弹出。<br>\n　　（13）接收到标记生成器释放的结束标签标记（标签名为 “body”）后，树构建起会将之前插入开放元素栈的HTMLBodyElement元素弹出。当前状态切换至 “after body” 模式。<br>\n　　（14）接收到标记生成器释放的结束标签标记（标签名为 “html”）后，树构建器会将之前插入开放元素栈的HTMLHtmlElement元素弹出。当前状态切换至 “after after body” 模式。<br>\n　　（15）接收到标记生成器释放的EOF标记后，树构建器会停止构建。<br>\n　　（16）整个html文档解析过程完成。<br>\n　　使用树状图表示树构建器生成的DOM树结构如图2所示：</p>\n<div style=\"text-align: center;\">\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3d274b2835d9ef12f533593115d03231/042e5/test_DOM.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 400px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 75.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABcSAAAXEgFnn9JSAAADX0lEQVQ4y5WUWUxTQRSGb2998EENilFDBCUIJhoi4UU0ioCEpUCraFpKhbYsgrIoizEEDAZEWQq0Qi9LF6AsZY/IA5iAiQHaYqFAF6BsgvhgTExADTuMc2/ZxJDoJCfnZs43/+T892QQZHMFYAMonulCjSurVA+4UsM6W2JY5UgMG4Elug2GUHN9N7fv8klrRShpb3GQTAhiA17BUiOIlY+Bx/WfiBwkHQUM4YD7luBdvgLxz+0iztML1IhLvHhHkF0+TuZWTpPZFZOEIBPTmDGwAeqt1xoGDPrtAg0zoGjQhynsO4TXubIJcmj1NMouG0N3dYf893IIFZD27gEA/gaZxUNp9KKhLBiFAcVaER0bwuCNzniNkt6GMosGI1mlWimzRCuDUcMs1gogVwb3OTjDkU2R6AUfdwRjW+dASscieNr+CyS1zYFUJQDwIJ8o2qeiIVKDPl0BiFryux8gqX0ePO8GgCPRK3GkQL1GYgj7EZbIYBJklQxJuFJ9DQSqYFRyxLoW6JkfXruS2ECC9Zggka6aLcZD3xxsyrWBxYNhOBMkHiZDQZSBaXBh0r+b6MQj4OMhcrJl1JsD+3LhNTNoctt3UmzzVxJusl9er5VnjsreK0dp58fvu0YT9LtQ+WpHWn6v+dYZf4Hawjdf7QTrzlSB5qpntvI8hdd7gZanskFwQwMwjYmklJKhZ+po+SS4XzGyFFlpBBGykcXI2hkAW8a2R02sa4iqnQIPKkeXIkzMCuTX2BL9ommOijbnyKUQDZUa+qIh/LBqdDW62rgWVTW6HNP4Za9gY0zDZ4DXcAay6/B7Hf6DZQK4k9eDWKWYRL1zlCc9s1U2XrxeO0qe2sEtU3HWm6ey9eUpzbYEqbnKY545ynPumYozsPVLsF1b2LY1LV91mgBoWR3I5WedJsGXnYedktvNPV59sPDNVV28kdpu5v6i8wQ16/3BbUFezxEoaumW0XUKXup4M1Nh7ZrRZeGR2X3ij5ZJvnw0WKRT4N6FV4wsQF9WQsqGf4ZVTQFWiVawJRgi1dclNM2AuNqxhUfysbXE+vHlhLrx1dAyw/ym4CCRj3LkZOiDLq5pFnpoBHF1EyCmxrj+pPUbgLO4/QLcK9W1hMtn4Ys0vBEPmXCZEXDLjZDRr/4GUUrQZoBY7hsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"DOM树结构\"\n        title=\"\"\n        src=\"/static/3d274b2835d9ef12f533593115d03231/042e5/test_DOM.png\"\n        srcset=\"/static/3d274b2835d9ef12f533593115d03231/aff53/test_DOM.png 148w,\n/static/3d274b2835d9ef12f533593115d03231/d25eb/test_DOM.png 295w,\n/static/3d274b2835d9ef12f533593115d03231/042e5/test_DOM.png 400w\"\n        sizes=\"(max-width: 400px) 100vw, 400px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n</div>\n<div style=\"text-align: center;\">图 2 树构建器生成的DOM树</div>\n<h2>解析完成后浏览器的动作</h2>\n<p>　　当解析完html文档之后，浏览器会将文档状态标记为 “可交互” ，然后解析并执行处于 “defer” 模式下的javascript脚本。当脚本执行完毕之后，浏览器会在Document对象上触发 “DOMContentLoaded” 事件。当文档依赖的所有其他外部资源（如图片等）下载解析并完毕之后，浏览器会先将文档状态标记为 “完成” ，然后在Window对象上触发 “load” 事件。</p>\n<h2>script标签的defer和async属性</h2>\n<p>　　script标签的defer和async属性可以决定脚本的执行时机。对于type属性取值为 “module” 的script标签来说，设置其defer属性并不起作用，其只支持async属性。<br>\n　　对于type属性取值非 “module” 的script标签而言，当设置了async属性后，<strong>浏览器解析到该标签时会另起一个线程获取脚本（当脚本是外部文件时），待脚本准备好后，浏览器会立即解析并执行脚本，在脚本执行过程中，如果DOM解析未完成，则DOM解析暂停</strong>；当script标签设置了defer属性时，<strong>浏览器解析到该标签时同样会另起一个线程获取脚本（当脚本是外部文件时），与设置async属性不同的是，待脚本准备好后，浏览器并不会立即执行脚本，而是等到DOM解析完毕之后开始执行脚本</strong>；当没有设置defer或者async属性时，<strong>浏览器解析到script标签时会立即解析并执行脚本，与此同时，DOM的解析被阻塞</strong>；当script标签同时设置defer和async属性时，<strong>async的优先级高于defer</strong>。<br>\n　　对于type属性取值为 “module” 的script标签而言，当设置了async属性，浏览器解析到script标签时会<strong>另起一个线程获取该module所依赖的其他module，待所有module准备好后，浏览器会立即执行脚本，此时，如果DOM解析未完成，则DOM解析过程暂停</strong>；当script标签未设置async属性时，<strong>浏览器解析到script标签时同样会另起一个线程获取该module所依赖的其他module，待所有module准备好后，浏览器并不会立即执行脚本，而是等到DOM解析完成后再执行脚本</strong>。<br>\n　　script标签的defer和async属性对脚本执行和DOM解析带来的影响参见图3（引用自<a href=\"https://www.w3.org/TR/html5/semantics-scripting.html#element-attrdef-script-defer\">html5标准</a>）。</p>\n<div style=\"height: 10rem;\">\n<img width=\"100%\" height=\"100%\" src=\"/static/script_defer_async_effect-da8316d78a7ba93e18a4dc6dcaaf73e2.svg\" alt=\"defer&#x548C;async&#x5C5E;&#x6027;&#x5BF9;html&#x89E3;&#x6790;&#x5E26;&#x6765;&#x7684;&#x5F71;&#x54CD;\">\n</div>\n<div style=\"text-align: center;\">&#x56FE; 3 defer&#x548C;async&#x5C5E;&#x6027;&#x5BF9;html&#x89E3;&#x6790;&#x5E26;&#x6765;&#x7684;&#x5F71;&#x54CD;</div>\n<h2>参考文献</h2>\n<ol>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/\">html5rocks: How Browsers Work: Behind the scenes of modern web browsers</a></li>\n<li><a href=\"https://www.w3.org/TR/html5/syntax.html\">HTML: The HTML syntax</a></li>\n</ol>","frontmatter":{"title":"现代浏览器的工作原理（二）","date":"April 24, 2018","description":"笔记（一）对现代浏览器的组成，从比较宏观的校对对现代浏览器进行了介绍。从本博文开始，笔者将会从浏览器如何处理html、css以及javascript这些比较细微的角度对浏览器的工作原理进行介绍。本博文详细描述了现代浏览器如何解析html文档。"}}},"pageContext":{"slug":"/notes/20180424213011/","previous":{"fields":{"slug":"/tips/20180422162446/"},"frontmatter":{"title":"解决移动端网页开发“滚动穿透”问题"}},"next":{"fields":{"slug":"/notes/20180620190521/"},"frontmatter":{"title":"现代浏览器的工作原理（三）"}}}}