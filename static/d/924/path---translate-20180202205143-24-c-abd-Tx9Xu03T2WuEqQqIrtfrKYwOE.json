{"data":{"site":{"siteMetadata":{"title":"William's Blog","author":"William"}},"markdownRemark":{"id":"56e4be3c-283c-51b7-93df-3b5069c10e52","excerpt":"点击查看英文原文 延时比设置的时间长的原因 　　 setTimeout / setInterval 延时超出预期时间是由多种原因造成的。常见的原因归结如下： 限制延时不得低于4ms 　　在现代浏览器中，当回调函数嵌套达到一定级别或者在触发一定数量的setInterval之后，浏览器会限制setTimeout…","html":"<br>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Reasons_for_delays_longer_than_specified\"><strong>点击查看英文原文</strong></a></p>\n</blockquote>\n<h2>延时比设置的时间长的原因</h2>\n<p>　　<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\">setTimeout</a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\">setInterval</a>延时超出预期时间是由多种原因造成的。常见的原因归结如下：</p>\n<h3>限制延时不得低于4ms</h3>\n<p>　　在现代浏览器中，当回调函数嵌套达到一定级别或者在触发一定数量的setInterval之后，浏览器会限制setTimeout/setInterval回调函数的调用周期不得小于4ms。下面的示例代码会触发浏览器的限制动作：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　在Chrome和Firefox中，从第5次连续回调开始限制回调周期；Safari从第6次连续回调开始限制；Edge在第三次连续调用时开始限制。Gecko从<a href=\"https://developer.mozilla.org/en-US/Firefox/Releases/56\">版本 56</a>开始对setInterval调用采取与上述限制策略（它已经像这样处理setTimeout调用）。<br>\n　　浏览器触发限制行为的条件了略有差异，比如Firefox只要检测到setInterval调用就会触发限制行为而不是必须等到setInterval被调用一定次数。</p>\n<h3>非活动标签页中的延时被限制不得低于1000ms</h3>\n<p>　　浏览器为了减小后台标签页中的加载量（同时减小电池消耗），限制后台标签页setTimeout/setInterval回调函数触发频率每秒不超过一次。<br>\n　　Firefox从版本 5（详见<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=633421\">bug 633421</a>，通过dom.min<em>background</em>timeout<em>value可以修改1000ms这一常量）开始执行这一限制行为，Chrome从版本 11开始执行该行为。<br>\n　　在适用于安卓的Firefox浏览器中，从Firefox 14的[bug 736602](<a href=\"https://bugzilla.mozilla.org/show\">https://bugzilla.mozilla.org/show</a></em>bug.cgi?id=736602)开始，后台标签页的setTimeout/setInterval触发间隔被设置为15分钟，并且后台标签可以被完全卸载。<br>\n　　<strong>注：当后台标签页使用Web Audio API <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\">AudioContext</a>播放音频时，Firefox 50不对后台标签页进行限制。从Firefox 51开始，一旦后台标签页中出现了<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\">AudioContext</a>，即使页面没有播放音频，Firefox也不限制该页面。</strong></p>\n<h3>对追踪脚本的延时限制</h3>\n<p>　　从Firefox 55开始，追踪脚本（比如Google Analytics，任何Firefox通过其TP表识别的脚本URL）受到了进一步的限制。追踪脚本在前台页面运行时，其最小时间间隔仍然设置为4ms。但是当追踪脚本在后台标签页运行时，其最小延时被限制为10s，这将在文档首次加载之后30s生效。<br>\n　　控制这一限制行为的字段如下：</p>\n<ol>\n<li>dom.min<em>tracking</em>timeout_value: 4</li>\n<li>dom.min<em>tracking</em>background<em>timeout</em>value: 10000</li>\n<li>dom.timeout.tracking<em>throttling</em>delay: 30000</li>\n</ol>\n<h3>晚延时</h3>\n<p>　　除了浏览器的限制策略之外，当页面（或者操作系统/浏览器本身）忙于其他任务时，setTimeout/setInterval回调函数也会比预设的时间晚触发。值得关注的一点是，setTimeout/setInterval回调函数或者代码片段不能被执行直到调用setTimeout()的主线程结束。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo has been called'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'After setTimeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>　　要写入控制台的结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">After setTimeout\nfoo has been called</code></pre></div>\n<p>　　这是因为即使setTimeout被调用时延时设置为0，它也会被放置在一个执行队列中并且计划在下一个时机被执行而不是立即被执行。当前正在被执行的代码必须在执行队列中的任务被执行前执行完成，因此最终的执行顺序可能不符合预期。<br>\n　　为了在现代浏览器中实现0ms延时，可以参考<a href=\"https://dbaron.org/log/20100309-faster-timeouts\">这篇文章</a>介绍的使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\">postMessage()</a>的方案。</p>","frontmatter":{"title":"为什么setTimeout和setInterval的实际延时比设置的时间长","date":"February 02, 2018","description":"在前端开发中经常会使用setTimeout和setInterval来进行延时操作，但是代码实际运行起来后开发者往往发现真实延时要比代码中设置的延时量要长不少。设置setTimeout的延时量为0并不能实现真正的0毫秒延时。产生这种现象的原因是什么？本文对此进行了总结和讨论。"}}},"pageContext":{"slug":"/translate/20180202205143/","previous":{"fields":{"slug":"/tips/20180125192502/"},"frontmatter":{"title":"解决webpack中使用ejs-loader时模板嵌套的问题"}},"next":{"fields":{"slug":"/notes/20180312213842/"},"frontmatter":{"title":"WebSocket协议学习笔记"}}}}